/**
 * BasicInterpreter.ino
 *
 * Basic example of using ArduinoASTInterpreter library on ESP32-S3.
 * Executes a pre-compiled Arduino program from CompactAST binary format.
 *
 * DUAL-MODE OPERATION:
 * - Embedded Mode (USE_FILESYSTEM=false): Uses PROGMEM array (default)
 * - Filesystem Mode (USE_FILESYSTEM=true): Loads AST from LittleFS filesystem
 *
 * This example runs the BareMinimum.ino sketch (setup + empty loop) to
 * demonstrate the interpreter integration without any hardware dependencies.
 *
 * Hardware: Arduino Nano ESP32 (FQBN: arduino:esp32:nano_nora)
 *           8MB Flash, 8MB PSRAM, LittleFS partition
 * Arduino IDE: Install ESP32 board support first
 *
 * FILESYSTEM MODE SETUP:
 * 1. Upload AST files to data/ folder using ESP32 Sketch Data Upload plugin
 * 2. Set USE_FILESYSTEM=true below
 * 3. Upload sketch
 *
 * Expected Output:
 *   Arduino AST Interpreter 22.0.0
 *   Platform: ESP32
 *   Mode: [Embedded|Filesystem]
 *   AST Binary Size: 1132 bytes
 *   Starting interpreter...
 *   Program started successfully!
 */

#include <ArduinoASTInterpreter.h>
#include "FS.h"
#include <LittleFS.h>

// ============================================================================
// CONFIGURATION
// ============================================================================

// Set to true to load AST from LittleFS filesystem, false for embedded mode
#define USE_FILESYSTEM false

// LittleFS filesystem configuration
#define LITTLEFS_FORMAT_ON_FAIL true  // Auto-format on first use

// Default AST file to load (filesystem mode only)
#define DEFAULT_AST_FILE "/bareMinimum.ast"

// ============================================================================
// EMBEDDED MODE AST BINARY
// ============================================================================

// Pre-compiled CompactAST binary for BareMinimum.ino:
//   void setup() { }
//   void loop() { }
//
// Generated from: test_data/example_001.ast (BareMinimum.ino)
// Size: 1132 bytes
const uint8_t PROGMEM astBinary[] = {
  0x41, 0x53, 0x54, 0x50, 0x00, 0x01, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x76, 0x6f,
  0x69, 0x64, 0x00, 0x05, 0x00, 0x73, 0x65, 0x74, 0x75, 0x70, 0x00, 0x04,
  0x00, 0x6c, 0x6f, 0x6f, 0x70, 0x00, 0x00, 0x00, 0x01, 0x01, 0x04, 0x00,
  0x01, 0x00, 0x05, 0x00, 0x21, 0x01, 0x06, 0x00, 0x02, 0x00, 0x03, 0x00,
  0x04, 0x00, 0x50, 0x02, 0x03, 0x00, 0x0c, 0x00, 0x00, 0x51, 0x02, 0x03,
  0x00, 0x0c, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x21, 0x01, 0x06, 0x00,
  0x06, 0x00, 0x07, 0x00, 0x08, 0x00, 0x50, 0x02, 0x03, 0x00, 0x0c, 0x00,
  0x00, 0x51, 0x02, 0x03, 0x00, 0x0c, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};

// ============================================================================
// COMMAND HANDLER - Prints interpreter commands to Serial
// ============================================================================

class SerialCommandHandler : public arduino_interpreter::CommandCallback {
public:
    void onCommand(const std::string& jsonCommand) override {
        // Simply print commands to Serial Monitor
        Serial.println(jsonCommand.c_str());
    }
};

SerialCommandHandler commandHandler;

// Simple data provider for testing (no external sensors needed)
class SimpleDataProvider : public arduino_interpreter::SyncDataProvider {
public:
    int32_t getAnalogReadValue(int32_t pin) override {
        return 512; // Mid-range analog value (0-1023)
    }

    int32_t getDigitalReadValue(int32_t pin) override {
        return 0; // LOW
    }

    uint32_t getMillisValue() override {
        return millis(); // Use real ESP32 millis()
    }

    uint32_t getMicrosValue() override {
        return micros(); // Use real ESP32 micros()
    }

    uint32_t getPulseInValue(int32_t pin, int32_t state, uint32_t timeout) override {
        return 0; // Not implemented in this simple example
    }

    int32_t getLibrarySensorValue(const std::string& libraryName,
                                  const std::string& methodName,
                                  int32_t arg) override {
        return 0; // Not implemented in this simple example
    }
};

SimpleDataProvider dataProvider;
ASTInterpreter* interpreter = nullptr;
uint8_t* astBuffer = nullptr;  // Dynamically allocated AST buffer (filesystem mode)

// ============================================================================
// FILESYSTEM HELPER FUNCTIONS
// ============================================================================

/**
 * Initialize LittleFS filesystem
 * Returns: true on success, false on failure
 */
bool initFilesystem() {
    Serial.println("Initializing LittleFS filesystem...");

    if (!LittleFS.begin(LITTLEFS_FORMAT_ON_FAIL)) {
        Serial.println("✗ ERROR: LittleFS mount failed");
        Serial.println("  Make sure you uploaded data files using:");
        Serial.println("  Tools > ESP32 Sketch Data Upload");
        return false;
    }

    Serial.println("✓ LittleFS mounted successfully");

    // Print filesystem info
    size_t totalBytes = LittleFS.totalBytes();
    size_t usedBytes = LittleFS.usedBytes();
    size_t freeBytes = totalBytes - usedBytes;

    Serial.print("  Total: ");
    Serial.print(totalBytes / 1024);
    Serial.println(" KB");

    Serial.print("  Used: ");
    Serial.print(usedBytes / 1024);
    Serial.println(" KB");

    Serial.print("  Free: ");
    Serial.print(freeBytes / 1024);
    Serial.println(" KB");
    Serial.println();

    return true;
}

/**
 * List all files in LittleFS filesystem
 */
void listFilesystem() {
    Serial.println("Files in LittleFS:");

    File root = LittleFS.open("/");
    if (!root || !root.isDirectory()) {
        Serial.println("  ERROR: Failed to open root directory");
        return;
    }

    File file = root.openNextFile();
    int fileCount = 0;

    while (file) {
        if (!file.isDirectory()) {
            Serial.print("  ");
            Serial.print(file.name());
            Serial.print(" (");
            Serial.print(file.size());
            Serial.println(" bytes)");
            fileCount++;
        }
        file = root.openNextFile();
    }

    if (fileCount == 0) {
        Serial.println("  No files found");
    } else {
        Serial.print("  Total: ");
        Serial.print(fileCount);
        Serial.println(" files");
    }
    Serial.println();
}

/**
 * Read AST file from LittleFS filesystem
 *
 * @param path File path (e.g., "/bareMinimum.ast")
 * @param size Output parameter for file size
 * @return Pointer to allocated buffer containing AST data, or nullptr on failure
 *
 * IMPORTANT: Caller must free() the returned buffer after use
 */
uint8_t* readASTFromFile(const char* path, size_t* size) {
    Serial.print("Reading AST file: ");
    Serial.println(path);

    File file = LittleFS.open(path, "r");
    if (!file) {
        Serial.println("✗ ERROR: Failed to open file");
        return nullptr;
    }

    *size = file.size();
    Serial.print("  File size: ");
    Serial.print(*size);
    Serial.println(" bytes");

    // Use PSRAM for large files (>10KB), regular heap for smaller files
    uint8_t* buffer;
    if (*size > 10240) {
        Serial.println("  Allocating from PSRAM...");
        buffer = (uint8_t*)ps_malloc(*size);
    } else {
        Serial.println("  Allocating from heap...");
        buffer = (uint8_t*)malloc(*size);
    }

    if (!buffer) {
        Serial.println("✗ ERROR: Memory allocation failed");
        file.close();
        return nullptr;
    }

    // Read file into buffer
    size_t bytesRead = file.read(buffer, *size);
    file.close();

    if (bytesRead != *size) {
        Serial.print("✗ ERROR: Read mismatch (got ");
        Serial.print(bytesRead);
        Serial.print(" bytes, expected ");
        Serial.print(*size);
        Serial.println(" bytes)");
        free(buffer);
        return nullptr;
    }

    Serial.println("✓ File read successfully");
    return buffer;
}

/**
 * Free AST buffer (handles both PSRAM and heap allocations)
 */
void freeASTBuffer(uint8_t* buffer) {
    if (buffer) {
        free(buffer);  // free() works for both ps_malloc() and malloc()
    }
}

// ============================================================================
// SETUP
// ============================================================================

void setup() {
    Serial.begin(115200);
    delay(1000);  // Give serial time to initialize

    Serial.println("=== Arduino AST Interpreter 22.0.0 ===");
    Serial.print("Platform: ");
    Serial.println(PLATFORM_NAME);

    #if USE_FILESYSTEM
        Serial.println("Mode: Filesystem");
    #else
        Serial.println("Mode: Embedded");
    #endif

    Serial.println();

    // Configure interpreter options
    InterpreterOptions opts;
    opts.verbose = true;      // Enable verbose output
    opts.debug = false;       // Disable debug tracing
    opts.maxLoopIterations = 1;  // Run loop once
    opts.syncMode = true;     // Use synchronous data provider

    const uint8_t* astData = nullptr;
    size_t astSize = 0;
    bool useFilesystem = USE_FILESYSTEM;

    // ========================================================================
    // FILESYSTEM MODE
    // ========================================================================
    #if USE_FILESYSTEM
    {
        // Try to initialize filesystem
        if (!initFilesystem()) {
            Serial.println("⚠ WARNING: Falling back to embedded mode");
            useFilesystem = false;
        } else {
            // List files for debugging
            listFilesystem();

            // Read AST file
            astBuffer = readASTFromFile(DEFAULT_AST_FILE, &astSize);

            if (astBuffer) {
                Serial.print("AST Size: ");
                Serial.print(astSize);
                Serial.println(" bytes");
                Serial.println();
                astData = astBuffer;
            } else {
                Serial.println("⚠ WARNING: Failed to load AST from file");
                Serial.println("⚠ WARNING: Falling back to embedded mode");
                useFilesystem = false;
            }
        }
    }
    #endif

    // ========================================================================
    // EMBEDDED MODE (default or fallback)
    // ========================================================================
    if (!useFilesystem) {
        Serial.print("AST Binary Size: ");
        Serial.print(sizeof(astBinary));
        Serial.println(" bytes");
        Serial.println();

        astData = astBinary;
        astSize = sizeof(astBinary);
    }

    // ========================================================================
    // CREATE INTERPRETER
    // ========================================================================
    Serial.println("Creating interpreter...");
    interpreter = new ASTInterpreter(astData, astSize, opts);

    // Free filesystem buffer if used (interpreter makes internal copy)
    if (useFilesystem && astBuffer) {
        freeASTBuffer(astBuffer);
        astBuffer = nullptr;
        Serial.println("✓ AST buffer freed (interpreter has internal copy)");
    }

    // Connect data provider and command handler
    interpreter->setSyncDataProvider(&dataProvider);
    interpreter->setCommandCallback(&commandHandler);

    // ========================================================================
    // START EXECUTION
    // ========================================================================
    Serial.println("Starting interpreter...");
    if (interpreter->start()) {
        Serial.println("✓ Program started successfully!");
        Serial.println();

        if (!useFilesystem) {
            Serial.println("Running embedded BareMinimum.ino:");
            Serial.println("  void setup() { }");
            Serial.println("  void loop() { }");
            Serial.println();
            Serial.println("To use filesystem mode:");
            Serial.println("  1. Upload data files: Tools > ESP32 Sketch Data Upload");
            Serial.println("  2. Set USE_FILESYSTEM=true in sketch");
            Serial.println("  3. Re-upload sketch");
        }
    } else {
        Serial.println("✗ ERROR: Failed to start program");
    }
}

// ============================================================================
// LOOP
// ============================================================================

void loop() {
    // Interpreter runs to completion in setup()
    // For more complex programs with async operations, call interpreter->resume() here
    delay(1000);
}
